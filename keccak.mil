; CONSTANTS
; Keccakf-rounds 24 (n)

; map a 2d (x,y) coordinate of a state vector to 1d index
(fn lane-idx (x y)
    (+ x (* y 5)))

; rotl64 : Bytes -> U256 -> Bytes
(fn rotl64 (b n)
    (xor (or (<< b n) (>> b (- 96 n))) 115792089237316195423570985008687907853269984665640564039439137263839420088320))
    ;(xor (or (<< b n) (>> b 96)) 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000))
    ;((a >> (64-(n%64))) + (a << (n%64))) % (1 << 64)

; Compute the keccak-f[1600] permutation given the state
(fn state-permute (state)
    (let (c v-nil
          ; rotation constants
          rotc [1 3 6 10 15 21 28 36 45 55 2 14
                27 41 56 8  25 43 62 18 39 61 20 44])
          ;piln [10 7 11 17 18 3 5 16 8 21 24 4
          ;      15 23 19 13 12 2 20 14 22 9 6 1])

        ; Theta-step
        ; ----
        (let (i 0) (loop 5 (let ()
            (set! c
                (v-push c
                    (xor (xor (xor
                      (v-get state (+ i 5))
                      (v-get state (+ i 10)))
                      (v-get state (+ i 15)))
                      (v-get state (+ i 20)))))
            (set! i (+ i 1)))))
        (let (i 0) (loop 5
            (let (t (xor (v-get c (% (+ i 4) 5))
                         (rotl64 (v-get c (% (+ i 1) 5)) 1)))
                (let (j 0) (loop 5 (let ()
                    (set! state
                        (v-from state (+ j i)
                            (xor (v-get state (+ j i)) t)))
                    (set! j (+ j 5)))))
            (set! i (+ i 1)))))

        ; Rho and pi steps
        ; ----
        (let (current (v-get state 1)
              x 1
              y 0)
            (let (t 0) (loop 25
                ; UNSURE: I see conflicting implementations on r?
                (let (r (% (/ (* (+ t 1) (+ t 2)) 2) 64)
                      Y (% (+ (* x 2) (* y 3)) 5))
                    (set! x y)
                    (set! y Y)
                    (set! current (v-get state (lane-idx x y)))
                    (set! state
                        (v-from state
                            (lane-idx x y)
                            (rotl64 current r)))
                    (set! t (+ t 1))))))

        ; Chi step
        (let (y 0) (loop 5
            ; temp = state[..5, y]
            (let (temp (v-slice state
                           (lane-idx 0 y)
                           (lane-idx 5 y)))
                (let (x 0) (loop 5 (let ()
                    (set! state
                        (v-from state
                                (lane-idx x y)
                                (xor (v-get temp x)
                                     (and (not (v-get temp (% (+ x 1) 5)))
                                          (v-get temp (% (+ x 2) 5))))))
                    (set! x (+ x 1)))))
                (set! y (+ y 1)))))
))


; Keccak-f[1600]
; f is the permutation which transforms the sponge construction
(fn keccak-f (state)
    (let ()
        (let (i 0)
            (loop 24 (state-permute state)))
        state))

(keccak-f [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])
